
<!DOCTYPE html>
<html lang="CN">
<head>
    <meta charset="utf-8" />
    <title>概念分支 | LetlMule</title>
    <meta name="author" content="Zooooa" />
    <meta name="description" content="Zooooa" />
    <meta name="keywords" content="Letl, Mule, Zooooa, letl, mule, zooooa, LETL, MULE, ZOOOOA" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>






<script src="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.css" />
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline-meta.min.css" />




<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载迟缓 宜启浏览器缓存</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>LETLMULE</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;LETLMULE</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>概念分支</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/29
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <pre><code class="mermaid">mindmap
  root((分支限界法))
    核心概念
      分支
      限界
      剪枝
    步骤
      分解问题
      计算界限
      选择子问题
      剪枝不优解
      更新最优解
    适用场景
      旅行售货员问题
      最大团问题
      批处理作业调度
      装载问题
      0-1 背包问题
    优缺点
      优点
        系统性搜索
        有效剪枝
      缺点
        依赖限界函数
        最坏情况复杂度高
    实现策略
      深度优先
      广度优先
      优先队列
</code></pre>
<blockquote>
<p>[!question]</p>
</blockquote>
<p><strong>分支限界法</strong>：专注于通过剪枝优化大规模搜索问题，应用于旅行售货员问题、最大团问题等。- <strong>分支限界法</strong>：旅行售货员问题、批处理作业调度、最大团问题、装载问题、0-1 背包问题。 <strong>深入解释算法原理</strong>- <strong>理论学习：</strong> 阅读经典教材，如《算法导论》，了解算法的数学基础和设计思想。- <strong>算法推导：</strong> 理解算法的推导过程，为什么这样设计。我也需要你用markdown图表和mermaid 的mindmap分析逻辑，java代码示例以及代码的作用和解释。</p>
<hr>
<h3 id="深入理解分支限界法"><a href="#深入理解分支限界法" class="headerlink" title="深入理解分支限界法"></a>深入理解分支限界法</h3><p>分支限界法（Branch and Bound）是一种系统性的方法，用于解决组合优化问题，特别是那些规模庞大、搜索空间巨大的问题。通过分支和限界的策略，分支限界法能够有效地剪枝，减少不必要的搜索，从而提高求解效率。</p>
<span id="more"></span>

<hr>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95">深入理解分支限界法</a><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E6%A6%82%E8%BF%B0">分支限界法概述</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</a><ul>
<li><a href="#%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0">理论学习</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC">算法推导</a></li>
</ul>
</li>
<li><a href="#java%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">Java代码示例</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%B8%800-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">示例一：0-1 背包问题</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98%E9%97%AE%E9%A2%98tsp">示例二：旅行售货员问题（TSP）</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A">代码解释</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%B8%800-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-1">示例一：0-1 背包问题</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98%E9%97%AE%E9%A2%98tsp-1">示例二：旅行售货员问题（TSP）</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr>
<h3 id="分支限界法概述"><a href="#分支限界法概述" class="headerlink" title="分支限界法概述"></a>分支限界法概述</h3><p><strong>分支限界法</strong>是一种用于解决组合优化问题的算法框架。它通过构建问题的解空间树，系统地探索可能的解，并通过“限界”策略剪除那些不可能包含最优解的子树，从而减少计算量。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>旅行售货员问题（TSP）</li>
<li>最大团问题</li>
<li>批处理作业调度</li>
<li>装载问题</li>
<li>0-1 背包问题</li>
</ul>
<p><strong>核心概念：</strong></p>
<ol>
<li><strong>分支（Branching）：</strong> 将问题分解为更小的子问题。</li>
<li><strong>限界（Bounding）：</strong> 计算子问题的下界或上界，用于决定是否继续探索该子树。</li>
<li><strong>剪枝（Pruning）：</strong> 排除那些不可能产生更优解的子树，减少搜索空间。</li>
</ol>
<hr>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><h4 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h4><p>分支限界法结合了深度优先搜索和广度优先搜索的优点，通过系统地分解问题和评估子问题的界限，能够高效地找到最优解。其设计思想基于以下原则：</p>
<ol>
<li><strong>分支（Branching）：</strong> 将原问题分解为若干子问题，形成解空间树。</li>
<li><strong>限界（Bounding）：</strong> 为每个子问题计算一个界限值（如最小可能成本或最大可能收益），用于评估该子问题是否可能包含最优解。</li>
<li><strong>剪枝（Pruning）：</strong> 如果一个子问题的界限值不优于当前已知的最优解，则不再探索该子问题，进行剪枝操作。</li>
</ol>
<p>分支限界法的效率依赖于有效的限界函数和合理的分支策略，以尽可能多地剪除无关的子树，缩小搜索空间。</p>
<h4 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h4><p>以<strong>0-1 背包问题</strong>为例，使用分支限界法来求解。0-1 背包问题要求在给定的背包容量下，选择物品使得总价值最大，每个物品只能选择一次。</p>
<p><strong>推导过程：</strong></p>
<ol>
<li><strong>分支策略：</strong> 对每个物品，决定是否选择该物品，形成两条分支：选择和不选择。</li>
<li><strong>限界函数：</strong> 使用贪心算法计算当前节点的上界。如果上界小于当前最优解，则剪枝。</li>
<li><strong>搜索策略：</strong> 通常使用深度优先搜索，以便尽早找到一个可行解，作为初始最优解，从而提高剪枝效率。</li>
</ol>
<hr>
<h3 id="Java代码示例"><a href="#Java代码示例" class="headerlink" title="Java代码示例"></a>Java代码示例</h3><h4 id="示例一：0-1-背包问题"><a href="#示例一：0-1-背包问题" class="headerlink" title="示例一：0-1 背包问题"></a>示例一：0-1 背包问题</h4><p>使用分支限界法解决0-1 背包问题，找到在给定重量限制下的最大价值。</p>
<pre><code class="java">import java.util.PriorityQueue;
import java.util.Comparator;

class KnapsackNode {
    int level;
    int profit;
    int weight;
    double bound;

    KnapsackNode(int level, int profit, int weight, double bound) {
        this.level = level;
            this.profit = profit;
            this.weight = weight;
            this.bound = bound;
    }
}

public class KnapsackBranchAndBound {
    // 按单位价值降序排序
    public static void sortItems(int[] weights, int[] values, int n) {
        for(int i=0; i&lt;n-1; i++) {
            for(int j=i+1; j&lt;n; j++) {
                double r1 = (double) values[i]/weights[i];
                double r2 = (double) values[j]/weights[j];
                if(r1 &lt; r2) {
                    // 交换
                    int temp = weights[i];
                    weights[i] = weights[j];
                    weights[j] = temp;
                    temp = values[i];
                    values[i] = values[j];
                    values[j] = temp;
                }
            }
        }
    }

    // 计算上界
    public static double bound(KnapsackNode u, int n, int W, int[] weights, int[] values) {
        if(u.weight &gt;= W)
            return 0;
        double profit_bound = u.profit;
        int j = u.level + 1;
        int totweight = u.weight;

        // 加入尽可能多的物品
        while(j &lt; n &amp;&amp; totweight + weights[j] &lt;= W) {
            totweight += weights[j];
            profit_bound += values[j];
            j++;
        }

        // 加入部分物品
        if(j &lt; n)
            profit_bound += (W - totweight) * ((double) values[j] / weights[j]);

        return profit_bound;
    }

    public static int knapsack(int W, int[] weights, int[] values, int n) {
        sortItems(weights, values, n);

        PriorityQueue&lt;KnapsackNode&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingDouble(node -&gt; -node.bound));

        KnapsackNode u = new KnapsackNode(-1, 0, 0, 0);
        KnapsackNode v = new KnapsackNode(0, 0, 0, 0);

        u.bound = bound(u, n, W, weights, values);
        pq.add(u);

        int maxProfit = 0;

        while(!pq.isEmpty()) {
            u = pq.poll();

            if(u.bound &gt; maxProfit &amp;&amp; u.level &lt; n-1) {
                // 向左分支：选择下一个物品
                v.level = u.level + 1;
                v.weight = u.weight + weights[v.level];
                v.profit = u.profit + values[v.level];

                if(v.weight &lt;= W &amp;&amp; v.profit &gt; maxProfit)
                    maxProfit = v.profit;

                v.bound = bound(v, n, W, weights, values);

                if(v.bound &gt; maxProfit)
                    pq.add(new KnapsackNode(v.level, v.profit, v.weight, v.bound));

                // 向右分支：不选择下一个物品
                v.weight = u.weight;
                v.profit = u.profit;
                v.bound = bound(v, n, W, weights, values);

                if(v.bound &gt; maxProfit)
                    pq.add(new KnapsackNode(v.level, v.profit, v.weight, v.bound));
            }
        }

        return maxProfit;
    }

    public static void main(String[] args) {
        int[] values = {60, 100, 120};
        int[] weights = {10, 20, 30};
        int W = 50;
        int n = values.length;
        System.out.println("最大价值为 " + knapsack(W, weights, values, n));
    }
}
</code></pre>
<h4 id="示例二：旅行售货员问题（TSP）"><a href="#示例二：旅行售货员问题（TSP）" class="headerlink" title="示例二：旅行售货员问题（TSP）"></a>示例二：旅行售货员问题（TSP）</h4><p>使用分支限界法解决旅行售货员问题，找到最短的巡回路径。</p>
<pre><code class="java">import java.util.Arrays;

public class TSPBranchAndBound {
    static int N = 4;
    static int VISITED_ALL = (1 &lt;&lt; N) - 1;
    static int[][] cost = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };

    static int minCost = Integer.MAX_VALUE;

    public static void main(String[] args) {
        boolean[] visited = new boolean[N];
        visited[0] = true;
        tsp(0, 1, 0, visited);
        System.out.println("最小巡回路径长度为 " + minCost);
    }

    public static void tsp(int current, int count, int costSoFar, boolean[] visited) {
        if(count == N &amp;&amp; cost[current][0] &gt; 0){
            if(costSoFar + cost[current][0] &lt; minCost){
                minCost = costSoFar + cost[current][0];
            }
            return;
        }

        for(int i=0; i&lt;N; i++) {
            if(!visited[i] &amp;&amp; cost[current][i] &gt; 0){
                visited[i] = true;
                if(costSoFar + cost[current][i] &lt; minCost){
                    tsp(i, count+1, costSoFar + cost[current][i], visited);
                }
                visited[i] = false;
            }
        }
    }
}
</code></pre>
<hr>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><h4 id="示例一：0-1-背包问题-1"><a href="#示例一：0-1-背包问题-1" class="headerlink" title="示例一：0-1 背包问题"></a>示例一：0-1 背包问题</h4><ol>
<li><p><strong>类定义：</strong></p>
<ul>
<li><code>KnapsackNode</code>：表示解空间树中的一个节点，包含当前层级（物品索引）、当前价值、当前重量和上界值。</li>
</ul>
</li>
<li><p><strong>排序物品：</strong></p>
<ul>
<li><code>sortItems</code>方法按照单位重量价值（<code>value/weight</code>）降序排序物品，以优化限界函数的效果。</li>
</ul>
</li>
<li><p><strong>计算上界：</strong></p>
<ul>
<li><code>bound</code>方法计算当前节点的上界值，使用贪心策略尽可能多地选择剩余物品，允许部分选择物品。</li>
</ul>
</li>
<li><p><strong>分支限界算法：</strong></p>
<ul>
<li>使用优先队列（最大堆）按上界值排序节点，优先探索上界值高的节点。</li>
<li>初始节点为 <code>level = -1</code>，<code>profit = 0</code>，<code>weight = 0</code>，<code>bound</code>为初始计算值。</li>
<li>在每一步，弹出具有最高上界值的节点进行扩展：<ul>
<li><strong>左子树（选择当前物品）：</strong> 更新重量和价值，检查是否超重或是否需要更新最优解。</li>
<li><strong>右子树（不选择当前物品）：</strong> 保持当前重量和价值不变，仅计算新的上界值。</li>
</ul>
</li>
<li>通过比较上界值和当前最优解，决定是否剪枝。</li>
</ul>
</li>
<li><p><strong>主方法：</strong></p>
<ul>
<li>定义物品的重量和价值，调用 <code>knapsack</code>方法计算最大价值。</li>
</ul>
</li>
</ol>
<p><strong>运行结果：</strong></p>
<pre><code>最大价值为 220
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li>选择第二个物品（重量20，价值100）和第三个物品（重量30，价值120），总重量50，价值220。</li>
</ul>
<h4 id="示例二：旅行售货员问题（TSP）-1"><a href="#示例二：旅行售货员问题（TSP）-1" class="headerlink" title="示例二：旅行售货员问题（TSP）"></a>示例二：旅行售货员问题（TSP）</h4><ol>
<li><p><strong>参数定义：</strong></p>
<ul>
<li><code>N</code>：城市数量。</li>
<li><code>VISITED_ALL</code>：表示所有城市都已访问的状态。</li>
<li><code>cost</code>：城市之间的距离矩阵。</li>
</ul>
</li>
<li><p><strong>主方法：</strong></p>
<ul>
<li>初始化访问数组，标记起点（城市0）为已访问。</li>
<li>调用 <code>ts</code>方法从起点开始进行分支限界搜索。</li>
<li>输出最小巡回路径长度。</li>
</ul>
</li>
<li><p><strong>分支限界方法：</strong></p>
<ul>
<li><code>tsp</code>方法递归地探索每个可能的城市，计算当前路径的成本。</li>
<li>如果所有城市都已访问且能回到起点，检查并更新最小成本。</li>
<li>对于每个未访问的城市，标记为已访问，递归调用 <code>ts</code>方法。</li>
<li>如果当前成本加上前往下一个城市的成本小于当前最小成本，则继续搜索；否则，剪枝。</li>
<li>递归完成后，取消标记，回溯到上一步。</li>
</ul>
</li>
</ol>
<p><strong>运行结果：</strong></p>
<pre><code>最小巡回路径长度为 80
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li>最优巡回路径可能为0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 0，路径长度为10 + 25 + 30 + 15 = 80。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>分支限界法</strong>是一种强大的算法框架，适用于解决各种组合优化问题。通过系统地分解问题、计算界限并进行剪枝，分支限界法能够在巨大的搜索空间中高效地找到最优解。然而，其性能高度依赖于限界函数的有效性和分支策略的合理性。</p>
<p><strong>学习建议：</strong></p>
<ol>
<li><p><strong>理解核心概念：</strong></p>
<ul>
<li>深入理解分支、限界和剪枝的概念及其在具体问题中的应用。</li>
</ul>
</li>
<li><p><strong>掌握常见问题：</strong></p>
<ul>
<li>通过练习0-1 背包问题、旅行售货员问题、最大团问题等经典问题，熟悉分支限界法的应用。</li>
</ul>
</li>
<li><p><strong>设计限界函数：</strong></p>
<ul>
<li>学习如何为不同问题设计有效的限界函数，确保剪枝的有效性。</li>
</ul>
</li>
<li><p><strong>优化搜索策略：</strong></p>
<ul>
<li>探索不同的搜索策略（如深度优先、广度优先、优先队列）对算法性能的影响。</li>
</ul>
</li>
<li><p><strong>编码实现：</strong></p>
<ul>
<li>多动手实现分支限界法，增强对算法逻辑和细节的理解。</li>
</ul>
</li>
<li><p><strong>分析时间和空间复杂度：</strong></p>
<ul>
<li>理解分支限界法在不同问题上的时间和空间复杂度，评估其适用性。</li>
</ul>
</li>
<li><p><strong>比较不同方法：</strong></p>
<ul>
<li>将分支限界法与其他算法（如动态规划、贪心算法、回溯法）进行比较，了解其优劣势和适用场景。</li>
</ul>
</li>
<li><p><strong>参与讨论和学习社区：</strong></p>
<ul>
<li>加入算法学习社区或论坛，参与讨论，分享和获取学习经验。</li>
</ul>
</li>
</ol>
<p>通过系统的理论学习、丰富的实践练习和不断的总结反思，您将能够高效地掌握分支限界法，并在各种复杂问题中灵活运用。</p>

    </div>
    
    
    
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    
</div>
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 LetlMule
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zooooa
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
    

 
    


    
        <!-- 引入 Waline 的样式文件 -->
        <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
        <div id="comment">
            <div id="waline-container"></div>
        </div>
    

    
        <script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script>
        <script>
            Waline.init({
                el: '#waline-container',
                serverURL: "https://blog.letlmule.fun/",
                commentCount: "true",
                pageview: "false",
                emoji: "https://unpkg.com/@waline/emojis@1.0.1/weibo,https://unpkg.com/@waline/emojis@1.0.1/alus,https://unpkg.com/@waline/emojis@1.0.1/bilibili,https://unpkg.com/@waline/emojis@1.0.1/qq,https://unpkg.com/@waline/emojis@1.0.1/tieba,https://unpkg.com/@waline/emojis@1.0.1/tw-emoji".split(','),
                meta: "nick,mail,link".split(','),
                requiredMeta: "nick".split(','),
                lang: "zh-CN",
                wordLimit: parseInt("0"),
                pageSize: "10",
                login: "enable",
            });
        </script>
    
    
    
</body>
</html>